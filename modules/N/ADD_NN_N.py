# Хведынич Варвара Андреевна, гр. 4381

from modules.N.N_NUM import NNum
from modules.N.com_nn_d import COM_NN_D_f


def ADD_NN_N_f(a: NNum, b: NNum) -> NNum:
    """
    Функция сложения двух натуральных чисел. Для удобства будем считать за a большее число.
    В случае, если это не окажется таковым, значения чисел a и b поменяются местами

    a - первое натуральное число.

    b - второе натуральное число.

    Возврат - NNum.
    """

    # Проверка какое число больше. Как я уже писала выше для удобства 
    # большее число будет лежать в а. Если это не так, то большее число
    # будет лежать в а
    if COM_NN_D_f(a, b) == 1:
        a, b = b, a

    # копируем данные большего массива и его длину для удобства, ибо
    # длина результата >= большее из чисел 
    result_digits = a.A.copy()
    result_len = a.n

    # заводим переменную переноса (carry) и начинаем цикл по длине меньшего числа
    # складываем начиная с меньших разрядов
    carry = 0
    for i in range(b.n):
        tmp_result = result_digits[i] + b.A[i] + carry
        result_digits[i] = tmp_result % 10
        carry = tmp_result // 10

    # обработка оставшегося переноса. Срабатывает в тот момент,
    # когда все цифры меньшего числа были просуммированы, но остался перенос
    # и остались необработанные старшие разряды в большем числе 
    i = b.n
    while carry > 0 and i < result_len:
        tmp_result = result_digits[i] + carry
        result_digits[i] = tmp_result % 10
        carry = tmp_result // 10
        i += 1

    # в случае, если перенос после всех разрядов остался,
    # происходит добавление нового разряда 
    if carry > 0:
        result_digits.append(carry)
        result_len += 1

    return NNum(result_len, result_digits)